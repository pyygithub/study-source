(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{372:function(t,e,n){t.exports=n.p+"assets/img/proxy_server.e57d8482.png"},373:function(t,e,n){t.exports=n.p+"assets/img/zx_proxy.4ca9baee.png"},374:function(t,e,n){t.exports=n.p+"assets/img/fx_proxy.13c03970.png"},504:function(t,e,n){"use strict";n.r(e);var a=n(19),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"nginx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx"}},[t._v("#")]),t._v(" Nginx")]),t._v(" "),a("h2",{attrs:{id:"第-1-章-什么是-nginx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第-1-章-什么是-nginx"}},[t._v("#")]),t._v(" 第 1 章 什么是 Nginx")]),t._v(" "),a("h3",{attrs:{id:"_1-1-概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-概述"}},[t._v("#")]),t._v(" 1.1 概述")]),t._v(" "),a("p",[t._v("Nginx 是一款高性能的 HTTP 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师 Igor Sysoev 所开发，官方测试 Nginx 能够支支撑 5 万并发链接，并且 CPU、内存等资源消耗却非常低，运行非常稳定。")]),t._v(" "),a("h3",{attrs:{id:"_1-2-nginx-的应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-nginx-的应用场景"}},[t._v("#")]),t._v(" 1.2 Nginx 的应用场景")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("HTTP 服务器：Nginx 是一个 HTTP 服务可以独立提供 HTTP 服务。可以做网页静态服务器。")])]),t._v(" "),a("li",[a("p",[t._v("虚拟主机：可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。")])]),t._v(" "),a("li",[a("p",[t._v("反向代理，负载均衡：当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 Nginx 做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。")])])]),t._v(" "),a("h2",{attrs:{id:"第-2-章-nginx-虚拟主机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第-2-章-nginx-虚拟主机"}},[t._v("#")]),t._v(" 第 2 章 Nginx 虚拟主机")]),t._v(" "),a("h3",{attrs:{id:"_2-1-概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-概述"}},[t._v("#")]),t._v(" 2.1 概述")]),t._v(" "),a("p",[t._v("我们使用 Docker 来安装和运行 Nginx，"),a("code",[t._v("docker-compose.yml")]),t._v(" 配置如下：")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("version")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'3.1'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("services")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("nginx")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("restart")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" always\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("image")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nginx\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("container_name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nginx\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("ports")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token datetime number"}},[t._v("81:80")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("volumes")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" ./conf/nginx.conf"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("/etc/nginx/nginx.conf\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" ./wwwroot"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("/usr/share/nginx/wwwroot\n")])])]),a("h3",{attrs:{id:"_2-2-什么是虚拟主机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-什么是虚拟主机"}},[t._v("#")]),t._v(" 2.2 什么是虚拟主机？")]),t._v(" "),a("p",[t._v("虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供 www 服务，这样就可以实现一台主机对外提供多个 web 服务，每个虚拟主机之间是独立的，互不影响的。")]),t._v(" "),a("p",[t._v("通过 Nginx 可以实现虚拟主机的配置，Nginx 支持三种类型的虚拟主机配置")]),t._v(" "),a("ul",[a("li",[t._v("基于 IP 的虚拟主机")]),t._v(" "),a("li",[t._v("基于域名的虚拟主机")]),t._v(" "),a("li",[t._v("基于端口的虚拟主机")])]),t._v(" "),a("h3",{attrs:{id:"_2-3-nginx-配置文件结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-nginx-配置文件结构"}},[t._v("#")]),t._v(" 2.3 Nginx 配置文件结构")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("# ...\nevents {\n\t# ...\n}\n\nhttp {\n\t# ...\n\tserver{\n\t\t# ...\n\t}\n\t\n\t# ...\n\tserver{\n\t\t# ...\n\t}\n}\n")])])]),a("blockquote",[a("p",[a("strong",[t._v("注：")]),t._v(" 每个 server 就是一个虚拟主机")])]),t._v(" "),a("h3",{attrs:{id:"_2-4-基于端口的虚拟主机配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-基于端口的虚拟主机配置"}},[t._v("#")]),t._v(" 2.4 基于端口的虚拟主机配置")]),t._v(" "),a("h4",{attrs:{id:"需求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#需求"}},[t._v("#")]),t._v(" 需求")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Nginx 对外提供 80 和 8080 两个端口监听服务")])]),t._v(" "),a("li",[a("p",[t._v("请求 80 端口则请求 html80 目录下的 html")])]),t._v(" "),a("li",[a("p",[t._v("请求 8080 端口则请求 html8080 目录下的 html")])])]),t._v(" "),a("h4",{attrs:{id:"创建目录及文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建目录及文件"}},[t._v("#")]),t._v(" 创建目录及文件")]),t._v(" "),a("p",[t._v("在 "),a("code",[t._v("/usr/local/docker/nginx/wwwroot")]),t._v(" 目录下创建 "),a("code",[t._v("html80")]),t._v(" 和 "),a("code",[t._v("html8080")]),t._v(" 两个目录，并分辨创建两个 index.html 文件")]),t._v(" "),a("h4",{attrs:{id:"配置虚拟主机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置虚拟主机"}},[t._v("#")]),t._v(" 配置虚拟主机")]),t._v(" "),a("p",[t._v("修改 "),a("code",[t._v("/usr/local/docker/nginx/conf")]),t._v(" 目录下的 nginx.conf 配置文件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("# 启动进程,通常设置成和 CPU 的数量相等\nworker_processes  1;\n\nevents {\n    # epoll 是多路复用 IO(I/O Multiplexing) 中的一种方式\n    # 但是仅用于 linux2.6 以上内核,可以大大提高 nginx 的性能\n    use epoll;\n    # 单个后台 worker process 进程的最大并发链接数\n    worker_connections  1024;\n}\n\nhttp {\n    # 设定 mime 类型,类型由 mime.type 文件定义\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    # sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，\n    # 必须设为 on，如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，降低系统的 uptime.\n    sendfile        on;\n    \n    # 连接超时时间\n    keepalive_timeout  65;\n    # 设定请求缓冲\n    client_header_buffer_size 2k;\n\n    # 配置虚拟主机 192.168.75.145\n    server {\n\t# 监听的ip和端口，配置 192.168.75.145:80\n        listen       80;\n\t# 虚拟主机名称这里配置ip地址\n        server_name  192.168.75.145;\n\t# 所有的请求都以 / 开始，所有的请求都可以匹配此 location\n        location / {\n\t    # 使用 root 指令指定虚拟主机目录即网页存放目录\n\t    # 比如访问 http://ip/index.html 将找到 /usr/local/docker/nginx/wwwroot/html80/index.html\n\t    # 比如访问 http://ip/item/index.html 将找到 /usr/local/docker/nginx/wwwroot/html80/item/index.html\n\n            root   /usr/share/nginx/wwwroot/html80;\n\t    # 指定欢迎页面，按从左到右顺序查找\n            index  index.html index.htm;\n        }\n\n    }\n    # 配置虚拟主机 192.168.75.245\n    server {\n        listen       8080;\n        server_name  192.168.75.145;\n\n        location / {\n            root   /usr/share/nginx/wwwroot/html8080;\n            index  index.html index.htm;\n        }\n    }\n}\n")])])]),a("h3",{attrs:{id:"_2-5-基于域名的虚拟主机配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-基于域名的虚拟主机配置"}},[t._v("#")]),t._v(" 2.5 基于域名的虚拟主机配置")]),t._v(" "),a("h4",{attrs:{id:"需求-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#需求-2"}},[t._v("#")]),t._v(" 需求")]),t._v(" "),a("ul",[a("li",[t._v("两个域名指向同一台 Nginx 服务器，用户访问不同的域名显示不同的网页内容")]),t._v(" "),a("li",[t._v("两个域名是 admin.service.itoken.pyy.com 和 admin.web.itoken.pyy.com")]),t._v(" "),a("li",[t._v("Nginx 服务器使用虚拟机 192.168.75.145")])]),t._v(" "),a("h4",{attrs:{id:"配置-windows-hosts-文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置-windows-hosts-文件"}},[t._v("#")]),t._v(" 配置 Windows Hosts 文件")]),t._v(" "),a("ul",[a("li",[t._v("通过 host 文件指定 admin.service.itoken.funtl.com 和 admin.web.itoken.funtl.com 对应 192.168.75.145 虚拟机：")]),t._v(" "),a("li",[t._v("修改 window 的 hosts 文件：（C:\\Windows\\System32\\drivers\\etc）")])]),t._v(" "),a("h4",{attrs:{id:"创建目录及文件-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建目录及文件-2"}},[t._v("#")]),t._v(" 创建目录及文件")]),t._v(" "),a("p",[t._v("在 "),a("code",[t._v("/usr/local/docker/nginx/wwwroot")]),t._v(" 目录下创建 "),a("code",[t._v("htmlservice")]),t._v(" 和 "),a("code",[t._v("htmlweb")]),t._v(" 两个目录，并分辨创建两个 index.html 文件")]),t._v(" "),a("h4",{attrs:{id:"配置虚拟主机-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置虚拟主机-2"}},[t._v("#")]),t._v(" 配置虚拟主机")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("user  nginx;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    sendfile        on;\n\n    keepalive_timeout  65;\n    server {\n        listen       80;\n        server_name  admin.service.itoken.funtl.com;\n        location / {\n            root   /usr/share/nginx/wwwroot/htmlservice;\n            index  index.html index.htm;\n        }\n\n    }\n\n    server {\n        listen       80;\n        server_name  admin.web.itoken.funtl.com;\n\n        location / {\n            root   /usr/share/nginx/wwwroot/htmlweb;\n            index  index.html index.htm;\n        }\n    }\n}\n")])])]),a("h2",{attrs:{id:"第-3-章-nginx-反向代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第-3-章-nginx-反向代理"}},[t._v("#")]),t._v(" 第 3 章 Nginx 反向代理")]),t._v(" "),a("h3",{attrs:{id:"_3-1-什么是代理服务器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-什么是代理服务器"}},[t._v("#")]),t._v(" 3.1 什么是代理服务器")]),t._v(" "),a("p",[t._v("代理服务器，客户机在发送请求时，不会直接发送给目的主机，而是先发送给代理服务器，代理服务接受客户机请求之后，再向主机发出，并接收目的主机返回的数据，存放在代理服务器的硬盘中，再发送给客户机。")]),t._v(" "),a("p",[a("img",{attrs:{src:n(372),alt:""}})]),t._v(" "),a("h3",{attrs:{id:"_3-2-为什么要使用代理服务器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-为什么要使用代理服务器"}},[t._v("#")]),t._v(" 3.2 为什么要使用代理服务器")]),t._v(" "),a("h4",{attrs:{id:"提高访问速度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提高访问速度"}},[t._v("#")]),t._v(" 提高访问速度")]),t._v(" "),a("p",[t._v("由于目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到了缓存的作用，尤其对于热门站点能明显提高请求速度。")]),t._v(" "),a("h4",{attrs:{id:"防火墙作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#防火墙作用"}},[t._v("#")]),t._v(" 防火墙作用")]),t._v(" "),a("p",[t._v("由于目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到了缓存的作用，尤其对于热门站点能明显提高请求速度。")]),t._v(" "),a("h4",{attrs:{id:"通过代理服务器访问不能访问的目标站点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过代理服务器访问不能访问的目标站点"}},[t._v("#")]),t._v(" 通过代理服务器访问不能访问的目标站点")]),t._v(" "),a("p",[t._v("互联网上有许多开放的代理服务器，客户机在访问受限时，可通过不受限的代理服务器访问目标站点，通俗说，我们使用的翻墙浏览器就是利用了代理服务器，虽然不能出国，但也可直接访问外网。")]),t._v(" "),a("h3",{attrs:{id:"_3-3-什么是正向代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-什么是正向代理"}},[t._v("#")]),t._v(" 3.3 什么是正向代理")]),t._v(" "),a("p",[t._v("正向代理，架设在客户机与目标主机之间，只用于代理内部网络对 Internet 的连接请求，客户机必须指定代理服务器,并将本来要直接发送到 Web 服务器上的 Http 请求发送到代理服务器中。")]),t._v(" "),a("p",[a("img",{attrs:{src:n(373),alt:""}})]),t._v(" "),a("h3",{attrs:{id:"_3-4-什么是反向代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-什么是反向代理"}},[t._v("#")]),t._v(" 3.4 什么是反向代理？")]),t._v(" "),a("p",[t._v("反向代理服务器架设在服务器端，通过缓冲经常被请求的页面来缓解服务器的工作量，将客户机请求转发给内部网络上的目标服务器；并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器与目标主机一起对外表现为一个服务器。")]),t._v(" "),a("p",[a("img",{attrs:{src:n(374),alt:""}})]),t._v(" "),a("h3",{attrs:{id:"_3-5-反向代理有哪些主要应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-反向代理有哪些主要应用"}},[t._v("#")]),t._v(" 3.5 反向代理有哪些主要应用？")]),t._v(" "),a("p",[t._v("现在许多大型 web 网站都用到反向代理。除了可以防止外网对内网服务器的恶性攻击、缓存以减少服务器的压力和访问安全控制之外，还可以进行负载均衡，将用户请求分配给多个服务器。")]),t._v(" "),a("h3",{attrs:{id:"_3-6-使用-nginx-反向代理-tomcat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-使用-nginx-反向代理-tomcat"}},[t._v("#")]),t._v(" 3.6 使用 Nginx 反向代理 Tomcat")]),t._v(" "),a("h4",{attrs:{id:"需求-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#需求-3"}},[t._v("#")]),t._v(" 需求")]),t._v(" "),a("ul",[a("li",[t._v("两个 tomcat 服务通过 nginx 反向代理")]),t._v(" "),a("li",[t._v("nginx 服务器：192.168.75.145:80")]),t._v(" "),a("li",[t._v("tomcat1 服务器：192.168.75.145:9090")]),t._v(" "),a("li",[t._v("tomcat2 服务器：192.168.75.145:9091")])]),t._v(" "),a("h4",{attrs:{id:"启动-tomcat-容器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#启动-tomcat-容器"}},[t._v("#")]),t._v(" 启动 Tomcat 容器")]),t._v(" "),a("p",[t._v("启动两个 Tomcat 容器，映射端口为 9090 和 9091，docker-compose.yml 如下：")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("version: '3'\nservices:\n  tomcat1:\n    image: tomcat\n    container_name: tomcat1\n    ports:\n      - 9090:8080\n\n  tomcat2:\n    image: tomcat\n    container_name: tomcat2\n    ports:\n      - 9091:8080\n")])])]),a("h4",{attrs:{id:"配置-nginx-反向代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置-nginx-反向代理"}},[t._v("#")]),t._v(" 配置 Nginx 反向代理")]),t._v(" "),a("p",[t._v("修改 "),a("code",[t._v("/usr/local/docker/nginx/conf")]),t._v(" 目录下的 nginx.conf 配置文件：")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("user  nginx;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    sendfile        on;\n\n    keepalive_timeout  65;\n\t\n\t# 配置一个代理即 tomcat1 服务器\n\tupstream tomcatServer1 {\n\t\tserver 192.168.75.145:9090;\n\t}\n\n\t# 配置一个代理即 tomcat2 服务器\n\tupstream tomcatServer2 {\n\t\tserver 192.168.75.145:9091;\n\t}\n\n\t# 配置一个虚拟主机\n\tserver {\n\t\tlisten 80;\n\t\tserver_name admin.service.itoken.funtl.com;\n\t\tlocation / {\n\t\t\t\t# 域名 admin.service.itoken.funtl.com 的请求全部转发到 tomcat_server1 即 tomcat1 服务上\n\t\t\t\tproxy_pass http://tomcatServer1;\n\t\t\t\t# 欢迎页面，按照从左到右的顺序查找页面\n\t\t\t\tindex index.jsp index.html index.htm;\n\t\t}\n\t}\n\n\tserver {\n\t\tlisten 80;\n\t\tserver_name admin.web.itoken.funtl.com;\n\n\t\tlocation / {\n\t\t\t# 域名 admin.web.itoken.funtl.com 的请求全部转发到 tomcat_server2 即 tomcat2 服务上\n\t\t\tproxy_pass http://tomcatServer2;\n\t\t\tindex index.jsp index.html index.htm;\n\t\t}\n\t}\n}\n")])])]),a("blockquote",[a("p",[t._v("注意：新版 Nginx 的 "),a("code",[t._v("upstream")]),t._v(' 配置中的名称不可以有下划线("_")，否则会报 '),a("code",[t._v("400")]),t._v(" 错误")])]),t._v(" "),a("h2",{attrs:{id:"第-4-章-nginx-负载均衡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第-4-章-nginx-负载均衡"}},[t._v("#")]),t._v(" 第 4 章 Nginx 负载均衡")]),t._v(" "),a("h3",{attrs:{id:"_4-1-什么是负载均衡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-什么是负载均衡"}},[t._v("#")]),t._v(" 4.1 什么是负载均衡")]),t._v(" "),a("p",[t._v("负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。")]),t._v(" "),a("p",[t._v("负载均衡，英文名称为 Load Balance，其意思就是分摊到多个操作单元上进行执行，例如 Web 服务器、FTP 服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。")]),t._v(" "),a("h3",{attrs:{id:"_4-2-nginx-实现负载均衡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-nginx-实现负载均衡"}},[t._v("#")]),t._v(" 4.2 Nginx 实现负载均衡")]),t._v(" "),a("ul",[a("li",[t._v("nginx 作为负载均衡服务器，用户请求先到达 nginx，再由 nginx 根据负载配置将请求转发至 tomcat 服务器")]),t._v(" "),a("li",[t._v("nginx 负载均衡服务器：192.168.75.145:80")]),t._v(" "),a("li",[t._v("tomcat1 服务器：192.168.75.145:9090")]),t._v(" "),a("li",[t._v("tomcat2 服务器：192.168.75.145:9091")])]),t._v(" "),a("h3",{attrs:{id:"_4-3-nginx-配置负载均衡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-nginx-配置负载均衡"}},[t._v("#")]),t._v(" 4.3 Nginx 配置负载均衡")]),t._v(" "),a("p",[t._v("修改 "),a("code",[t._v("/usr/local/docker/nginx/conf")]),t._v(" 目录下的 nginx.conf 配置文件：")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("user  nginx;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    sendfile        on;\n\n    keepalive_timeout  65;\n\t\n\tupstream myapp1 {\n\t\tserver 192.168.75.145:9090 weight=10;\n\t\tserver 192.168.75.145:9091 weight=10;\n\t}\n\n\tserver {\n\t\tlisten 80;\n\t\tserver_name nginx.funtl.com;\n\t\tlocation / {\n\t\t\tproxy_pass http://myapp1;\n\t\t\tindex index.jsp index.html index.htm;\n\t\t}\n\t}\n}\n\n")])])]),a("h3",{attrs:{id:"_4-4-相关配置说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-相关配置说明"}},[t._v("#")]),t._v(" 4.4 相关配置说明")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("# 定义负载均衡设备的 Ip及设备状态 \nupstream myServer {\n    server 127.0.0.1:9090 down;\n    server 127.0.0.1:8080 weight=2;\n    server 127.0.0.1:6060;\n    server 127.0.0.1:7070 backup;\n}\n")])])]),a("p",[t._v("在需要使用负载的 Server 节点下添加")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("proxy_pass http://myServer;\n")])])]),a("ul",[a("li",[a("code",[t._v("upstream")]),t._v("：每个设备的状态:")]),t._v(" "),a("li",[a("code",[t._v("down")]),t._v("：表示当前的 "),a("code",[t._v("server")]),t._v(" 暂时不参与负载")]),t._v(" "),a("li",[a("code",[t._v("weight")]),t._v("：默认为 1 "),a("code",[t._v("weight")]),t._v(" 越大，负载的权重就越大。")]),t._v(" "),a("li",[a("code",[t._v("max_fails")]),t._v("：允许请求失败的次数默认为 1 当超过最大次数时，返回 "),a("code",[t._v("proxy_next_upstream")]),t._v(" 模块定义的错误")]),t._v(" "),a("li",[a("code",[t._v("fail_timeout")]),t._v(":"),a("code",[t._v("max_fails")]),t._v(" 次失败后，暂停的时间。")]),t._v(" "),a("li",[a("code",[t._v("backup")]),t._v("：其它所有的非 "),a("code",[t._v("backup")]),t._v(" 机器 "),a("code",[t._v("down")]),t._v(" 或者忙的时候，请求 "),a("code",[t._v("backup")]),t._v(" 机器。所以这台机器压力会最轻")])]),t._v(" "),a("h2",{attrs:{id:"第-5-章-使用-nginx-解决跨域问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第-5-章-使用-nginx-解决跨域问题"}},[t._v("#")]),t._v(" 第 5 章 使用 Nginx 解决跨域问题")]),t._v(" "),a("h3",{attrs:{id:"_5-1-概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-概述"}},[t._v("#")]),t._v(" 5.1 概述")]),t._v(" "),a("p",[t._v("在浏览器端进行 Ajax 请求时会出现跨域问题，那么什么是跨域，如何解决跨域呢？先看浏览器端出现跨域问题的现象，如下图所示")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://www.funtl.com/assets/Lusifer1520520301.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"_5-2-什么是跨域问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-什么是跨域问题"}},[t._v("#")]),t._v(" 5.2 什么是跨域问题？")]),t._v(" "),a("p",[t._v("跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript 施加的安全限制。")]),t._v(" "),a("h3",{attrs:{id:"_5-3-什么是同源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-什么是同源"}},[t._v("#")]),t._v(" 5.3 什么是同源？")]),t._v(" "),a("p",[t._v("所谓同源是指，域名，协议，端口均相同")]),t._v(" "),a("ul",[a("li",[t._v("http://www.baidu.com --\x3e http://admin.baidu.com 跨域")]),t._v(" "),a("li",[t._v("http://www.baidu.com --\x3e http://www.baidu.com 非跨域")]),t._v(" "),a("li",[t._v("http://www.baidu.com --\x3e http://www.baidu.com:8080 跨域")]),t._v(" "),a("li",[t._v("http://www.baidu.com --\x3e https://www.baidu.com 跨域")])]),t._v(" "),a("h3",{attrs:{id:"_5-4-如何解决跨域问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-如何解决跨域问题"}},[t._v("#")]),t._v(" 5.4 如何解决跨域问题？")]),t._v(" "),a("h4",{attrs:{id:"使用-cors-跨资源共享-解决跨域问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-cors-跨资源共享-解决跨域问题"}},[t._v("#")]),t._v(" 使用 CORS（跨资源共享）解决跨域问题")]),t._v(" "),a("p",[t._v('CORS 是一个 W3C 标准，全称是"跨域资源共享"（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。')]),t._v(" "),a("p",[t._v("CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信（在 "),a("code",[t._v("header")]),t._v(" 中设置："),a("code",[t._v("Access-Control-Allow-Origin")]),t._v("）")]),t._v(" "),a("h4",{attrs:{id:"使用-jsonp-解决跨域问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-jsonp-解决跨域问题"}},[t._v("#")]),t._v(" 使用 JSONP 解决跨域问题")]),t._v(" "),a("p",[t._v("JSONP（JSON with Padding）是 JSON 的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 "),a("code",[t._v("server1.example.com")]),t._v(" 的网页无法与 "),a("code",[t._v("server2.example.com")]),t._v(" 的服务器沟通，而 HTML 的 "),a("code",[t._v("元素是一个例外。利用")]),t._v(" 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的 JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析（需要目标服务器配合一个 "),a("code",[t._v("callback")]),t._v(" 函数）。")]),t._v(" "),a("h4",{attrs:{id:"cors-与-jsonp-的比较"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cors-与-jsonp-的比较"}},[t._v("#")]),t._v(" CORS 与 JSONP 的比较")]),t._v(" "),a("p",[t._v("CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。")]),t._v(" "),a("p",[t._v("JSONP 只支持 GET 请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。")]),t._v(" "),a("h3",{attrs:{id:"_5-5-使用-nginx-反向代理解决跨域问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-使用-nginx-反向代理解决跨域问题"}},[t._v("#")]),t._v(" 5.5 使用 Nginx 反向代理解决跨域问题")]),t._v(" "),a("p",[t._v("以上跨域问题解决方案都需要服务器支持，当服务器无法设置 "),a("code",[t._v("header")]),t._v(" 或提供 "),a("code",[t._v("callback")]),t._v(" 时我们就可以采用 Nginx 反向代理的方式解决跨域问题。")]),t._v(" "),a("p",[t._v("以下为文件上传的跨域配置方案：")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("user  nginx;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    sendfile        on;\n\n    keepalive_timeout  65;\n\n    server {\n        listen 80;\n        server_name upload.myshop.com;\n        add_header 'Access-Control-Allow-Origin'  '*';\n        add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range';\n        location / {\n            proxy_pass  http://192.168.0.104:8888;\n            if ($request_method = 'OPTIONS') {\n                add_header Access-Control-Allow-Origin  *;\n                add_header Access-Control-Allow-Headers X-Requested-With;\n                add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,PATCH,OPTIONS;\n                # 解决假请求问题，如果是简单请求则没有这个问题，但这里是上传文件，首次请求为 OPTIONS 方式，实际请求为 POST 方式\n                # Provisional headers are shown.\n                # Request header field Cache-Control is not allowed by Access-Control-Allow-Headers in preflight response.\n                add_header Access-Control-Allow-Headers DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range;\n                return 200;\n            }\n        }\n    }\n}\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);