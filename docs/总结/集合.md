# 集合

## 1. hashmap为什么长度要是2的n次幂

（1）保证 indexFor() 方法中的 位运算 等价于 取模运行 保证效率

​	在 hashmap 源码中有一个方法叫 indexFor() , 该方法其实主要就是将hash生产的整数转换为数组中的下标。

​	代码大概是：hash & (length - 1) 

​	这段代码其实就是 取模，而这里之所以使用 & 运算来代替 取模（%），主要是考虑效率。&运算效率高很多（位运算直接对数据进行运算，不需要转换为十进制，因此非常快！）

​	这正因为如此，hashmap resize 每次都是 2 倍扩容，也是为了保证这个（因为只要保证 length 长度是 2^n 的	话，就可以实现取模运算，保证效率

（2）JDK 1.8 hashmap源码中，就是运用这个技巧 对 resize（）后元素的索引重排进行，优化（保证扩容后，原有元素的索引位置不发生改变）

## 2. LinkedHashMap 和 HashMap 区别

LinkedHashMap继承于HashMap，是基于HashMap和双向链表来实现的。

HashMap 无序，LinkedHashMap 有序（插入顺序（默认：false），访问属性）

如果 初始化构造是选择是访问顺序 new LinkedHashMap(10, true) , 那put和get操作已存在的Entry时，都会把Entry移动到双向链表的表尾(其实是先删除再插入)。

LinkedHashMap存取数据，还是跟HashMap一样使用的Entry[]的方式，双向链表只是为了保证顺序。

LinkedHashMap是线程不安全的

## 3. LinkedHashMap 是如何实现 LRU的

其实很简单，就因为LinkedHashMap 本身有一个特性：初始化时可以指定 排序方式（插入排序，访问排序）

我们可以设置为访问排序（当访问某一个已存在的Entry后就会将移动到链表的尾部）

利用这个特性我们可以初始化一个LinkedHashMap 对象 指定初始化容量，和访问顺序模式），重写 removeEldestEntry 方法（这个方法返回true，就会移除就链表头的旧元素）减少哈希碰撞

```java
@Test
    public void testLinkedHashMap() {
        LinkedHashMap<String, String> map = new LinkedHashMap<String, String>(5, 0.75F, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {
                //当LinkHashMap的容量大于等于5的时候,再插入就移除旧的元素
                return this.size() >= 5;
            }
        };
        map.put("aa", "bb");
        map.put("cc", "dd");
        map.put("ee", "ff");
        map.put("gg", "hh");
        print(map);
        map.get("cc");
        System.out.println("===================================");
        print(map);

        map.get("ee");
        map.get("aa");
        System.out.println("====================================");
        map.put("ss","oo");
        print(map);
    }
```



### 4. HashMap 拉链法解决hash冲突

从HashMap的实现来看，我们总结拉链发的实现步骤如下：

1. 计算 key 的 hashValue
2. 根据 hashValue 值定位到 table[hashIndex] 。( table[hashIndex] 是一条链表Node)
3. 若 table[hashValue] 为空则直接插入，不然则添加到链表末尾

## 5. HashMap 的扩容时机

首先 我们在构造 HashMap 的时候可以指定 初始化容量 capicity 默认 16 ，负载因子默认0.75，

当使用put方法添加元素时，会判断当前hashmap的++size 和 threshold 比较 如果大于 阈值 就执行resize操作

- 扩容：创建一个新的Entry数组 容量是原数组的2倍
- rehash：遍历原数组，把所有的原始重新hash

## 6. 缓存穿透、缓存击穿、缓存雪崩区别和解决方案

**一、缓存处理流程**

   前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。

   ![img](./img/20180919143214712)

 

**二、缓存穿透**

​    **描述：**

​    缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

   **解决方案：**

1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击

 

**三、缓存击穿**

   **描述：**

   缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力

   **解决方案：**

1. 设置热点数据永远不过期。
2. 加互斥锁，互斥锁参考代码如下：

​     ![img](./img/20180919143214879)

 

​     说明：

​     1）缓存中有数据，直接走上述代码13行后就返回结果了

​     2）缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。

​     3）当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程A从数据库取key1的数据并不妨碍线程B取key2的数据，上面代码明显做不到这点。

 

**四、缓存雪崩**

   **描述：**

   缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，    缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

   **解决方案**：

1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
2. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
3. 设置热点数据永远不过期。

## 7. Spring Bean生命周期

系统启动时 spring 加载需要被spring管理的Bean对象，调用 实例化

然后完成属性的注入，接下来会调用 BeanNameAware.setBeanName方法初始化方法名称

接下来调用BeanFactoryAware.setBeanFactory 完毕bean工程注入

调用ApplicationContextAware.setApplicationContext()  applicationContext注入

BeanPostProcessor.postProcessBeforeInitialization()

然后调用init-method配置方法完成自定义初始化工作

BeanPostProcessor.postProcessAfterInitialization()

Bean 就可以使用了，

当系统关闭时会调用 用户配置的 destory-method  和 destory() 完成对象销毁



## 8. RocketMQ 如何保证高可用？

采用多master，多slave模式–同步双写





